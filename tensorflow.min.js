/** 构建TensorFlow.js顺序模型 (ANN) */
function buildModel(inputDim, hiddenUnits, activationFn) {
  const model = tf.sequential();
  // 输入层->隐藏层
  model.add(tf.layers.dense({
    inputShape: [inputDim],
    units: hiddenUnits,
    activation: activationFn  // 例如 'relu' 或 'sigmoid'
  }));
  // 隐藏层->输出层
  model.add(tf.layers.dense({
    units: 1,
    activation: 'linear'  // 线性输出，用于回归。如果预测分类可改为sigmoid等
  }));
  // 配置模型的优化器和损失函数
  model.compile({
    optimizer: tf.train.adam(),               // Adam优化器
    loss: tf.losses.meanSquaredError,         // 均方误差损失:contentReference[oaicite:12]{index=12}
    metrics: [tf.metrics.meanAbsoluteError]   // 指标: MAE（可根据需要添加）
  });
  return model;
}

/** 开始训练模型 (根据选择的验证方案执行不同流程) */
async function startTrainingModel() {
  // 从参数表单获取设置
  const hiddenNeurons = parseInt(document.getElementById('hidden-neurons').value);
  const epochCount = parseInt(document.getElementById('epoch-count').value);
  const activationFn = document.getElementById('activation-fn').value;
  const valMethod = document.querySelector('input[name="validation-method"]:checked').value;

  // 准备训练数据张量 (对于holdout，我们有trainData数组; 对于loocv，将每轮动态生成)
  let X_train, y_train, X_test, y_test;
  if (valMethod === 'holdout') {
    // 提取训练集特征和标签，转换为tf.tensor2d
    X_train = tf.tensor2d(trainData.map(d => d.X));
    y_train = tf.tensor2d(trainData.map(d => d.y), [trainData.length, 1]);
    X_test = tf.tensor2d(testData.map(d => d.X));
    y_test = tf.tensor2d(testData.map(d => d.y), [testData.length, 1]);
  }

  // 构建模型
  const inputDim = trainData[0].X.length || trainData[0].length; // 特征维度
  console.log(`构建模型: 输入维度=${inputDim}, 隐藏层神经元=${hiddenNeurons}, 激活=${activationFn}`);
  let model = buildModel(inputDim, hiddenNeurons, activationFn);
  // 输出模型摘要（可选，可用tfjs-vis或console查看）
  model.summary();

  if (valMethod === 'holdout') {
    // **Holdout 验证**: 直接使用划分好的训练集训练，测试集评估
    try {
      // 训练模型
      await model.fit(X_train, y_train, {
        epochs: epochCount,
        batchSize: 32,
        shuffle: true,
        validationData: [X_test, y_test],
        callbacks: {
          onEpochEnd: (epoch, logs) => {
            console.log(`Epoch ${epoch+1}/${epochCount}: loss=${logs.loss.toFixed(4)}, MAE=${logs.meanAbsoluteError.toFixed(4)}`);
            // 可选：在界面上显示训练进度，比如进度条或当前loss
          }
        }
      });
    } catch (err) {
      console.error("模型训练过程中出错:", err);
      alert("模型训练失败，请检查控制台日志。");
      return;
    }
    console.log("模型训练完成！");
    // 在测试集上进行预测
    const predsTensor = model.predict(X_test);
    const preds = Array.from(predsTensor.dataSync());  // 将预测结果Tensor转为JS数组
    const actuals = Array.from(y_test.dataSync());
    // 计算各项评估指标并显示结果
    evaluateAndDisplayResults(preds, actuals, model);
  } else if (valMethod === 'loocv') {
    // **留一交叉验证**: 每次留一条做测试，其余做训练，重复N次
    const allX = trainData;  // trainData在LOOCV模式下存的是整个数据集特征二维数组
    const allY = testData || [] ; // 这里为了通用把testData复用，在LOOCV中未用
    const N = allX.length;
    let sumAbsError = 0, sumAbsPctError = 0, sumSqError = 0, sumError = 0;
    const allActuals = [], allPreds = [];
    // LOOCV 循环
    for (let i = 0; i < N; i++) {
      // 切分训练和验证集: 第i条作为验证，其它作为训练
      const X_train_loocv = tf.tensor2d(allX.filter((_, idx) => idx !== i));
      const y_train_loocv = tf.tensor2d(y.filter((_, idx) => idx !== i), [N-1, 1]);
      const X_val_loocv = tf.tensor2d([ allX[i] ]);  // 留出的第i条
      const y_val_loocv = y[i];
      // 构建并训练模型（每次需新建模型，因为每轮训练独立进行）
      model = buildModel(inputDim, hiddenNeurons, activationFn);
      try {
        await model.fit(X_train_loocv, y_train_loocv, {
          epochs: epochCount,
          batchSize: Math.min(32, N-1),
          shuffle: true
          // LOOCV我们不需要专门验证集，每轮最后直接预测第i条即可
        });
      } catch (err) {
        console.error(`LOOCV第${i}折训练出错:`, err);
        return;
      }
      // 用训练好的模型预测第i条
      const predTensor = model.predict(X_val_loocv);
      const predVal = predTensor.dataSync()[0];
      allPreds.push(predVal);
      allActuals.push(y_val_loocv);
      // 累积误差用于之后计算平均指标
      const err = predVal - y_val_loocv;
      sumAbsError += Math.abs(err);
      if (y_val_loocv !== 0) {
        sumAbsPctError += Math.abs(err / y_val_loocv);
      }
      sumSqError += err * err;
      sumError += err;
      // 清理内存中的tensor以防止内存泄露
      tf.dispose([X_train_loocv, y_train_loocv, X_val_loocv, predTensor]);
      model.dispose();
    }
    // 所有折验证完毕，计算平均指标
    const MAE = sumAbsError / N;
    const MAPE = (sumAbsPctError / N) * 100;
    const MSE = sumSqError / N;
    const RMSE = Math.sqrt(MSE);
    const meanActual = allActuals.reduce((a,b) => a+b, 0) / N;
    const SST = allActuals.reduce((sum, y) => sum + Math.pow(y - meanActual, 2), 0);
    const R2 = 1 - (sumSqError / SST);
    const explainedVar = 1 - ( (sumSqError/N) / (SST/N) );  // 解释方差，可与R2相同
    const meanError = sumError / N;
    // 显示LOOCV平均指标（此模式下模型已重新初始化多次，不保留最终模型）
    displayMetrics({
      MAE, MAPE, MSE, RMSE, R2, explainedVar, meanError
    });
    // 存储预测和实际以便后续绘图分析（LOOCV情况下allPreds与allActuals为数组）
    plotResults(allPreds, allActuals, /* group info if needed */);
  }
}
