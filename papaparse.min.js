// 获取页面元素
const trainFileInput = document.getElementById('train-file-input');
const trainButton = document.getElementById('train-button');
const metricsOutput = document.getElementById('metrics-output');
const chartsOutput = document.getElementById('charts-output');
const trainingResultsSection = document.getElementById('training-results');

// 全局变量用于保存训练集/测试集数据
let trainData = [], testData = [];

/** 读取CSV文件并解析为JSON数组 */
function parseCSVFile(file, onComplete) {
  Papa.parse(file, {
    header: true,      // 首行作为列名
    dynamicTyping: true,  // 自动将数字字符串转换为Number类型
    complete: function(results) {
      if (results.errors.length) {
        console.error("CSV解析错误: ", results.errors);
        alert("CSV文件解析出错，请检查文件格式。");
      } else {
        // 调用回调，将解析得到的数据传出
        onComplete(results.data);
      }
    }
  });
}

// 当用户点击“开始训练模型”按钮时，触发流程
trainButton.addEventListener('click', () => {
  const file = trainFileInput.files[0];
  if (!file) {
    alert("请先选择训练数据CSV文件！");
    return;
  }
  // 解析CSV并处理数据
  parseCSVFile(file, (dataRows) => {
    // dataRows 是一个对象数组，每个元素对应CSV一行（已按header映射键值）
    if (dataRows.length === 0) {
      alert("CSV文件内容为空或无法解析数据。");
      return;
    }
    // 从表单获取列名配置
    const constructCol = document.getElementById('construct-col').value;
    const formatCol = document.getElementById('format-col').value;
    const scoreCol = document.getElementById('score-col').value;
    // 提取输入特征和标签
    // 假设每行有: 学生ID、题目ID 或描述、Construct、ItemFormat、Score 等等列
    // 我们将构建 feature 列表 (X) 和 label 列表 (y)
    let X = [], y = [];
    for (const row of dataRows) {
      // 忽略空行或无效行
      if (row[scoreCol] === undefined || row[scoreCol] === null) continue;
      // 准备特征向量: 这里我们将 Construct 和 ItemFormat 作为示例特征
      // 可以根据需要加入更多特征，例如学生ID或题目ID的编码、其他列等
      let features = [];
      // 处理Construct（假设为类别型变量）
      if (row[constructCol] !== undefined) {
        features.push(row[constructCol]);
      }
      // 处理Item Format（类别型变量）
      if (row[formatCol] !== undefined) {
        features.push(row[formatCol]);
      }
      // TODO: 可在此加入更多特征, 比如学生或题目的某些数值属性
      
      X.push(features);
      y.push(row[scoreCol]);
    }
    // 将特征X和标签y保存为全局，供后续训练使用
    prepareDataset(X, y);
  });
});

/** 对原始X, y数据进行预处理，并根据验证方法拆分训练/测试集或配置LOOCV */
function prepareDataset(X, y) {
  // 特征工程：处理分类变量，例如Construct和ItemFormat需要转换成数值编码或独热编码
  // 首先，找到所有可能的取值集合
  const constructSet = new Set();
  const formatSet = new Set();
  X.forEach(features => {
    if (features.length >= 1) constructSet.add(features[0]);
    if (features.length >= 2) formatSet.add(features[1]);
  });
  const constructValues = Array.from(constructSet);
  const formatValues = Array.from(formatSet);
  // 建立类别取值到索引的映射（用于独热编码或数值编码）
  const constructIndexMap = {};
  constructValues.forEach((val, idx) => { constructIndexMap[val] = idx; });
  const formatIndexMap = {};
  formatValues.forEach((val, idx) => { formatIndexMap[val] = idx; });

  // 将X转换为数值向量（示例采用独热编码construct和format）
  let X_processed = [];
  for (const feat of X) {
    // 独热编码向量长度 = construct种类数 + format种类数
    let vec = new Array(constructValues.length + formatValues.length).fill(0);
    if (feat[0] !== undefined && constructIndexMap[feat[0]] !== undefined) {
      vec[constructIndexMap[feat[0]]] = 1;
    }
    if (feat[1] !== undefined && formatIndexMap[feat[1]] !== undefined) {
      // format编码需要偏移construct编码长度
      let offset = constructValues.length;
      vec[offset + formatIndexMap[feat[1]]] = 1;
    }
    // 可选：如果有其他特征列，可以在此添加到vec中（并调整长度）
    X_processed.push(vec);
  }
  // 标签y直接使用。如果y非数值类型(例如是字符串表示等级)，需要转换为数值，这里假定PapaParse已将其转为Number

  // 转换完成，X_processed是二维数组 (样本数 × 特征维度)，y是标签数组
  // 下面按照验证方案拆分训练和测试数据
  const valMethod = document.querySelector('input[name="validation-method"]:checked').value;
  if (valMethod === 'holdout') {
    // 使用训练/测试拆分
    const trainRatio = parseInt(document.getElementById('train-ratio').value) / 100.0;
    const totalCount = X_processed.length;
    const trainCount = Math.floor(totalCount * trainRatio);
    // 将数据打乱顺序
    const indices = Array.from(X_processed.keys());
    tf.util.shuffle(indices);  // 利用tf.js提供的shuffle函数随机打乱索引:contentReference[oaicite:4]{index=4}
    trainData = [], testData = [];
    for (let i = 0; i < totalCount; i++) {
      const idx = indices[i];
      const dataPoint = { X: X_processed[idx], y: y[idx], student: null, format: null };
      // 记录student和format用于后续分组分析（假设原始X第一位是Construct，第二位是Format; 这里需要原始值，因此我们可以在prepareDataset开头额外存储原始construct和format列数组）
      // 为简化说明，此处暂未保存student ID。如果需要每学生RMSE，需要原始student标识，可在读取CSV时将student ID一起纳入features或单独存储映射。
      if (i < trainCount) {
        trainData.push(dataPoint);
      } else {
        testData.push(dataPoint);
      }
    }
    console.log(`使用Holdout拆分: 训练集 ${trainData.length} 条, 测试集 ${testData.length} 条`);
    startTrainingModel();  // 开始训练模型
  } else if (valMethod === 'loocv') {
    // 留一交叉验证不在此立即拆分，而是在训练过程中每轮留1做测试
    trainData = X_processed;
    testData = null;
    console.log("使用留一交叉验证进行模型评估");
    startTrainingModel();
  }
}
